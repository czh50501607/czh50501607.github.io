# 模块 1-part2

## 简答题

**一, 说明输出结果和原因**

```javascript
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // > 10
```

原因: var 有变量提升的特性, 当结束循环的时候 i 的 值为 10, 访问时就会访问执行过后的 i 的值。如果使用 let 则每一次循环都有作用域的限制

**二， 说明输出结果和原因**

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
// 报错, 不能在 变量初始化之前访问
```

原因: 变量的访问会先按作用域访问, 由内而外. 而在 if 作用域内已经声明了 tmp 变量, 但用 let 声明就不能在声明之前访问, 所以会报错

**三, 找出数组中最小值**

```javascript
var arr = [12, 34, 32, 89, 4];

Math.min(...arr);
```

**四, 说明 var,let,const 的区别**

> var 属于变量, 有变量提升，可重复声明的特性

> let 属于变量, 不可重复声明, 声明前不可访问.

> const 属于常量, 不可重复声明, 必须赋值, 初始化后值不可变, 声明前不可访问.

**五, 说明输出结果和原因**

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a);
    });
  },
};

obj.fn(); // 20
```

原因: setTimeout 的回调是箭头函数, 没有 this 所以, this.a 会找上一层 this 就到了 obj 这块 obj.a // >20
如果 setTimeout 的回调是普通 function 函数, 调用的是定时器方法, 而定时器指向的是 window, 所以指向的是 window.a // > 10

**六, 简述 Symbol 的用途**

Symbol 可以作为对象的 key，每使用一次 Symbol 就是一次唯一值，除非调用 `Symbol.for` 传入相等描述否则就不等. `Symbol.iterable` 可以提供给对象迭代器功能, 可以被 `for of` 调用

**七, 深浅拷贝**

浅拷贝: 对引用类型进行第一层复制, 拷贝一层不同的引用，但除第一层,拷贝出的对象内仍然有对 被拷贝 对象有引用, 比如树形结构。这就是浅拷贝

深拷贝: 把引用类型对象的值进行完全的复制. 与被拷贝的值结构相同 但 完全没有引用关系

**八, TS 与 JS 的关系**

typescript 是 JavaScript 的超集,一门语言, 兼容所有 es 版本的语法, 是对 js 类型声明缺点的补足, 完全可以用 JavaScript 书写, 编译器还可以支持语法提示。

**九, TypeScript 优缺点**

优点: 严格的类型声明, 对新手友好, 维护起来方便, 有语法提示。
缺点: 开发时速度相比原来稍慢

**十, 引用计数器的工作原理和优缺点**

设置引用数, 判断当前引用数是否为 0, 引用关系更改时修改引用数字
优点: 引用数一旦为 0 立刻回收
缺点: 无法回收循环引用对象, 时间开销大

**十一, 描述标记整理算法的工作流程**

标记整理是标记清除的增强，但不具有清除操作。只是将活动对象标记，然后移动对象位置。
避免空间碎片化的情况发生

**十二, 描述 v8 中新生代存储区垃圾回收的流程**

新生代内存区分为两个等大的空间
使用空间为 from，空闲空间为 to
活动对象处于 form 空间，标记整理后将 _活动对象_ 拷贝至 to
to 与 from 交换，删除 from。
to 空间使用率超过 25%或经过一轮 GC 还能存活下来的对象放入 老生代

**十三, 描述增量标记算法在何时使用及时工作原理**

在老生代回收的时候需要进行遍历，这时用到增量标记。
将垃圾回收步骤分为小段，代替一步做完的操作，让程序执行和垃圾回收交替进行，
标记一下，执行一下。减少停顿时间，增大回收频率。
